import math
from itertools import product

import pandas as pd

from bpllib import utils

import sys

from experiments.new import exp_utils

METRIC = sys.argv[1] if len(sys.argv) > 1 else 'f1'  # 'accuracy'
DATASETS = utils.easy_datasets + ['-'] + utils.medium_datasets + ['-'] + utils.hard_datasets
METHODS = ['Find-RS', 'RIPPER', 'ID3', 'AQ', 'BRS']

filename = '../new-results-merged-no-model.pkl'
df = exp_utils.get_df(['model'])  # pd.read_pickle(filename)
N = len(df)
print("% autogenerated by baseline_complexity.py (N={}, filename={})".format(N, filename))

df = df[(df['strategy'] == 'single')]

# group by dataset, method, encoding
df = df.groupby(['dataset', 'method', 'strategy', 'encoding']).agg(
    {'avg_ruleset_len': ['mean'], 'avg_rule_len': ['mean'], METRIC: ['mean']}).reset_index()

df = df.pivot_table(index=['dataset', 'method'], columns=['strategy', 'encoding'],
                    values=[METRIC, 'avg_ruleset_len', 'avg_rule_len']).reset_index()

# extract for each dataset/method the best encoding for the strategy single
df['best_encoding'] = df.apply(
    lambda row: 'av' if row[(METRIC, 'mean', 'single', 'av')] >= row[(METRIC, 'mean', 'single', 'ohe')] else 'ohe',
    axis=1)

df[(' base', 'compl.', '', '')] = df.apply(
    lambda row: row[('avg_ruleset_len', 'mean', 'single', row[('best_encoding', '', '', '')])], axis=1)
df[(' base', 'spec.', '', '')] = df.apply(
    lambda row: row[('avg_rule_len', 'mean', 'single', row[('best_encoding', '', '', '')])], axis=1)

df = df.pivot_table(index=['dataset'], columns=['method'], values=[' base'])  # .reset_index()

df = df.droplevel((2, 3), axis=1).swaplevel(0, axis=1).swaplevel(1, axis=1)
df.columns = df.columns.rename("strategy", level=1)
df.columns = df.columns.rename("metric", level=2)
df = df.reorder_levels(['method', "strategy", 'metric'], axis=1).sort_index(axis=1)
# print(df)

# select only metric='spec.'
# df1 = df.xs('spec.', level='metric', axis=1)

# df2 = df.xs('compl.', level='metric', axis=1)

# print a two level latex table
# print(df.to_latex(float_format="%.1f", multicolumn_format='c|', multirow=True).replace('NaN', '-'))
# print(df2.to_latex(float_format="%.1f", multicolumn_format='l', multirow=True))


print("""\\begin{tabular}{l|rr|rr|rr|rr|rr} \n \\toprule \n \\textbf{dataset}""", end='')
for method in METHODS:
    if method == 'BRS':
        print(f'& \\multicolumn{{2}}{{c}}{{\\textbf{{{method}}}}} ', end='')
    else:
        print(f'& \\multicolumn{{2}}{{c|}}{{\\textbf{{{method}}}}} ', end='')

print('\\\\')

print('\\textbf{metric} & compl. & spec. & compl. & spec. &  compl. & spec. & compl. & spec. & compl. & spec. \\\\')
print('\\hline')

for dataset in utils.easy_datasets + ['-'] + utils.medium_datasets + ['-'] + utils.hard_datasets:
    if dataset == '-':
        print('\\hline')
        continue
    print(f'\\texttt{{{dataset if dataset != "LYMPHOGRAPHY" else "LYMPH."}}}', end='')
    for method in METHODS:
        for metric in ['compl.', 'spec.']:
            val = df.loc[dataset, method][" base", metric]
            if math.isnan(val):
                print(f' & - ', end='')
            else:
                print(f' & {val:.1f} ', end='')
    print('\\\\')

print('\\hline')

print('\\textbf{median}', end='')
# print the median complexity and specificity for each method
for method in METHODS:
    for metric in ['compl.', 'spec.']:
        val = df.loc[:, method][" base", metric].median()
        print(f' & {val:.1f} ', end='')

print('\\\\')
print("""\\bottomrule""")
print("""\\end{tabular}""")
